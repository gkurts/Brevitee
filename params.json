{"name":"Brevitee","tagline":"Concision Providers and Productivity Tools -- bridging the gap between JavaScript, C# and SQL","body":"# Brevitee \r\nBrevitee is a framework and set of tools for rapid web application development.  \r\nIt offers data access code generation, web service generation, logging and \r\nunit testing tools.  Brevitee is built on top of ASP.net MVC and was designed \r\nto bridge the gap between JavaScript, C# and SQL with an emphasis on allowing great \r\nJavaScript developer's to collaborate, as peers, with .Net developer's while still \r\nutilizing a relational database system like SQL Server.\r\n\r\n## Why Brevitee?\r\nBrevitee consists of reusable code components that I've written over the years \r\nthat were used to contribute to numerous projects in a variety of professional \r\nroles I've held.  While there is functional overlap between Brevitee and other \r\nmore popular systems today, at the time of its creation either no equivalent \r\nexisted or the options did not provide the specific functionality and capabilities \r\nthat I was looking for.\r\n\r\n## No, I Mean Why Is It Called Brevitee?\r\nThe word brevity is defined as; concise and exact use of words in writing or speech.  \r\nIn the same sense Brevitee is intended, in the spirit of jQuery, to allow one to \r\nwrite less and do more through the use of Brevitee's extensive .Net extension method \r\nlibrary, jQuery plugins and other productivity enhancing JavaScripts.  At the time I \r\nfirst uploaded the Brevitee Nuget packages the name Brevity had already been taken,\r\nhence the spelling Brevitee :).\r\n\r\n## Data Access Objects (Dao)\r\nThe generation of data access objects can be done by extracting objects from an \r\nexisting SQL Server database or by processing a *.db.js file.  Due to its use \r\nprimarily as a greenfield technology, code generation from an existing SQL Server \r\ndatabase does not account for what I refer to as “silliness in the database” such \r\nas tables with no primary keys or tables with compound or composite primary keys.\r\n\r\n### Dao From LaoTze\r\nThe generation of data access objects is most easily done by creating a *.db.js \r\nfile and processing that file with the command line tool LaoTze.exe.  A *.db.js \r\nfile is a special JavaScript file that contains a single JavaScript literal object \r\nnamed “database” that defines a database schema.  An example database schema object\r\nis shown below.\r\n\r\n```javascript\r\nvar database = {\r\n\tnameSpace: “The.Namespace.That.Generated.Objects.Will.Be.Placed.In”,\r\n\tschemaName: “UsedAsTheConnectionStringNameInTheConfig”,\r\n\txrefs: [ // An array of arrays; \r\n\t\t// each entry defines a many to many relationship between the table \t\t\t\t\t\r\n\t\t// names specified\r\n\t\t[“LeftTable”, “RightTable”]\r\n\t],\r\n\ttables: [\r\n\t\t{\r\n\t\t\tname: “TheNameOfTheTable”,\r\n\t\t\tfks: [ \t// An array of foreign key definitions where the key is \r\n\t\t\t\t// the column name and the value is the name of the table \r\n\t\t\t\t// that the foreign key references\r\n\t\t\t\t{ ColumnName1: “ReferencedTable1” },\r\n\t\t\t\t{ ColumnName2: “ReferencedTable2” }\r\n\t\t\t],\r\n\t\t\tcols: [ \t// An array of column definitions\r\n\t\t\t\t{ ColumnName: “DataType”, Null: false || true } // \r\n\t\t\t]\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: “TableOne”,\r\n\t\t\tcols: [ \t\r\n\t\t\t\t{ Name: “String”, Null: false },\r\n\t\t\t\t{ Description: \"String\", Null: true }\r\n\t\t\t]\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"TableTwo\",\r\n\t\t\tfks: [\r\n\t\t\t\t{ TableOneId: \"TableOne\" }\r\n\t\t\t],\r\n\t\t\tcols: [\r\n\t\t\t\t{ Name: \"String\", Null: false },\r\n\t\t\t\t{ DescriptionTwo: \"String\", Null: true }\r\n\t\t\t]\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"LeftTable,\r\n\t\t\tcols: [\r\n\t\t\t\t{ LeftName: \"String\"}\r\n\t\t\t]\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"RightTable,\r\n\t\t\tcols: [\r\n\t\t\t\t{ RightName: \"String\"}\r\n\t\t\t]\r\n\t\t}\r\n\t\t{\t\t\r\n\t\t\t// … another table like above and so on\r\n\t\t}\t\t\r\n\t]\r\n}\r\n```\r\n\r\n### Dao From LaoTzu\r\nAnother way of generating data access objects is by extracting those objects \r\nfrom an existing SQL Server using LaoTzu.exe.  To reiterate, code generation from \r\nan existing SQL Server database does not account for what I refer to as \r\n“silliness in the database” such as tables with no primary keys or tables with \r\ncompound or composite primary keys so your mileage with this technique may vary.\r\n\r\n```\r\n// TODO: show screenshot of LaoTzu\r\n```\r\n\r\nLaoTze and LaoTzu both generate .Net (C#) code that can be used to quickly perform all \r\ndatabase CRUD (Create, Retrieve, Update, Delete) operations.\r\n\r\n```c#\r\n// Create\r\nTableOne one = new TableOne();\r\none.Name = \"TableOneName\";\r\none.Description = \"TableOne Description\";\r\none.Save();\r\n\r\n// Retrieve\r\nTableOne retrieved = TableOne.OneWhere(c => c.Name == \"TableOneName\");\r\n// or\r\nTableOneCollection retrieved = TableOne.Where(c => Name == \"TableOneName\");\r\n\r\n// Update\r\nretrieved.Description = \"The description updated\";\r\nretrieved.Save();\r\n\r\n// Delete\r\nretrieved.Delete();\r\n```\r\n\r\n## Web Services Using ServiceProxySystem\r\nCreating and exposing web services with Brevitee is as simple as defining \r\na .Net class and registering that class with the ServiceProxySystem early in the \r\napplication life-cycle, typically in the global.asax file or a custom AppStart Config\r\nclass.\r\n\r\n### Web Service Server \r\n```c#\r\n// Echo.cs\r\npublic class Echo\r\n{\r\n\tpublic string Test(string value)\r\n\t{\r\n\t\treturn value;\r\n\t}\r\n}\r\n\r\n// Application_Start in global.asax\r\nServiceProxySystem.Initialize();\r\nServiceProxySystem.Register<Echo>();\r\n```\r\n\r\nAlternatively if the Echo class were adorned with the Proxy attribute...\r\n```c#\r\n[Proxy]\r\npublic class Echo\r\n{\r\n}\r\n\r\n// ...it could then be registered like so;\r\nServiceProxySystem.RegisterBinProviders();\r\n```\r\nKeep in mind that using the RegisterBinProviders method will likely \r\nincur a performance hit on startup of the application as the \r\nServiceProxySystem will \"scour\" the bin directory looking for classes \r\nwith the Proxy attribute.\r\n\r\n### Web Service Endpoints\r\nThe web service endpoints or endpoint urls that are defined for each registered \r\nclass will conform to the following route signature:\r\n\r\n```\r\n/{VERB}/{ClassName}/{MethodName}.{ext}\r\n```\r\n\r\nWhere VERB is one of GET or POST.\r\n\r\n### Web Service Clients\r\nIn addition to automatically exposing any class that you choose as a\r\nweb service, the ServiceProxySystem will also automatically generate clients\r\non your behalf.\r\n\r\n#### C# Clients\r\nTo obtain C# client code simply download the code from a running ServiceProxySystem\r\ninstallation using the following path:\r\n\r\n```\r\n/ServiceProxy/CSharpProxies\r\n```\r\n\r\nYou may also specify an optional namespace that the clients will be defined in\r\n\r\n```\r\n/ServiceProxy/CSharpProxies?namespace=My.Name.Space\r\n```\r\n\r\n#### JavaScript Clients\r\nThe ServiceProxySystem also generates JavaScript clients as well which\r\ncan be downloaded in a similar fashion as the C# clients.  But, the recommended way\r\nof acquiring JavaScript clients would be to include a script tag in your pages\r\nwith the src attribute set to the JavaScript proxies path:\r\n\r\n```xml\r\n<script src=\"/ServiceProxy/JSProxies\"></script>\r\n```\r\n\r\n## Logging\r\nLogging using Brevitee is done through the static convenience class\r\nLog and it's various AddEntry methods.\r\n\r\nConfiguring logging with Brevitee is as simple as adding an entry to the \r\nappSettings section of the app.config or web.config file.\r\n\r\n```xml\r\n<add key=\"LogType\" value=\"Text\" />\r\n```\r\n\r\nAdditionally, you are also encouraged to add an entry identifying the application by name like\r\nso:\r\n\r\n```xml\r\n<add key=\"ApplicationName\" value=\"MyApplicationName\" />\r\n```\r\n\r\nThere are a number of Loggers included with Brevitee, they are:\r\n- Text\r\n- Csv\r\n- Xml\r\n- Windows\r\n\r\nThe logging implementation contained in Brevitee uses a single background commit thread\r\nto ensure that logging operations do not block the main application thread.  Because of this\r\nthe logging system should be started early in the application life-cycle by calling Log.Start().\r\nThis is typically done in the global.asax file or a custom AppStart Config class.\r\n\r\n### Defining a Custom Logger\r\nIf the included loggers do not meet your needs or you would otherwise like to define a logger of \r\nyour own that commits events to a custom store or other location you need only to extend the \r\nbase Logger class and implement the CommitLogEvent method.\r\n\r\n```c#\r\npublic class CustomLogger: Logger\r\n{\r\n\tpublic void CommitLogEvent(LogEvent event)\r\n\t{\r\n\t\t/// your logic here\r\n\t}\r\n}\r\n```\r\n\r\nTo configure the application to use a custom logger not included in Brevitee you \r\nwill need to specify the assembly qualified name in the app.config or web.config file.\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}