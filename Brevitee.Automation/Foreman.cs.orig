using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using Bryan.Apellanes;
using Bryan.Apellanes.Profiguration;
using Bryan.Apellanes.ServiceProxy;
using Bryan.Apellanes.Data;
using Bryan.Apellanes.Analytics;
using Bryan.Apellanes.Analytics.Metrics;
using System.Threading;

namespace Bryan.Apellanes.Automation
{
    /// <summary>
    /// The master orchestrator for 
    /// all jobs.
    /// </summary>
    [Proxy("fm")]
    public class Foreman
    {
        const string ProfigurationSetKey = "ForemanSettings";

        AutoResetEvent _enqueueSignal;
        AutoResetEvent _runCompleteSignal;
        Thread _runnerThread;
        public Foreman()
        {
            this.MaxConcurrentJobs = 3;
            this._enqueueSignal = new AutoResetEvent(false);
            this._runCompleteSignal = new AutoResetEvent(false);
        }

        static Foreman _default;
        static object _defaultLock = new object();
        public static Foreman Default
        {
            get
            {
                return _defaultLock.DoubleCheckLock(ref _default, () => new Foreman());
            }
        }

        public int MaxConcurrentJobs
        {
            get;
            set;
        }

        DirectoryInfo _jobsDirectory;
        public string JobsDirectory
        {
            get
            {
                if (_jobsDirectory == null)
                {
                    _jobsDirectory = new DirectoryInfo("{0}\\Jobs"._Format(this.GetAppDataFolder()));
                }

                return _jobsDirectory.FullName;
            }
            set
            {
                _jobsDirectory = new DirectoryInfo(value);
                _messageRoot = null; // forces reinit;
            }
        }

        List<Job> _running;
        object _runningLock = new object();
        public List<Job> Running
        {
            get
            {
                return _runningLock.DoubleCheckLock(ref _running, () => new List<Job>());
            }
        }

        IpcMessageRoot _messageRoot;
        object _messageRootLock = new object();
        protected internal IpcMessageRoot IpcMessageRoot
        {
            get
            {
                return _messageRootLock.DoubleCheckLock(ref _messageRoot, () => new IpcMessageRoot(JobsDirectory));
            }
        }

        ProfigurationSet _profigurationSet;
        object _profigurationSetLock = new object();
        protected internal ProfigurationSet ProfigurationSet
        {
            get
            {
                return _profigurationSetLock.DoubleCheckLock(ref _profigurationSet, () => new ProfigurationSet(Path.Combine(JobsDirectory, "ProfigurationSet")));
            }
        }

<<<<<<< HEAD
        public JobConf CreateJobConf(string name)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Adds a worker of generic type T to the
        /// specified JobConf.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="conf"></param>
        /// <returns></returns>
        public void AddWorker<T>(string name, JobConf conf)
        {
            AddWorker(typeof(T), name, conf);
        }

        public void AddWorker(Type type, string name, JobConf conf)
        {
            throw new NotImplementedException();
        }

        public void CreateJob(JobConf conf)
        {

        }

=======
        [Exclude]
>>>>>>> 990fde221ee77b9599dcafc9e3fbe0c02632eb7e
        public SuspendedJob SuspendJob(Job job)
        {
            SuspendedJob suspended = new SuspendedJob(IpcMessageRoot, job);
            return suspended;
        }

        [Exclude]
        public string SecureGet(string key)
        {
            Profiguration.Profiguration prof = ProfigurationSet[ProfigurationSetKey];
            return prof.AppSettings[key];
        }

        [Exclude]
        public string SecureSave(string key, string value)
        {
            Profiguration.Profiguration prof = ProfigurationSet[ProfigurationSetKey];
            prof.AppSettings[key] = value;
            ProfigurationSet.Save();

            return value;
        }

        public WorkerConf AddWorker(string workerType, string jobName)
        {
            throw new NotImplementedException();
        }

        public JobConf CreateJob(string name)
        {
            return CreateJobConf(name);
        }
        
        protected internal JobConf GetJobConf(string name)
        {
            throw new NotImplementedException();
        }

        protected internal JobConf CreateJobConf(string name)
        {
            JobConf conf = new JobConf(name);
            conf.JobDirectory = GetJobDirectoryPath(name);
            conf.Save();
            return conf;
        }

        public bool JobExists(string name)
        {
            string ignore;
            return JobExists(name, out ignore);
        }
        protected internal bool JobExists(string name, out string jobDirectoryPath)
        {
            jobDirectoryPath = Path.Combine(JobsDirectory, name);
            return Directory.Exists(jobDirectoryPath);
        }

        public void EnqueueJob(string name, int stepNumber = 0)
        {
            JobConf conf = new JobConf(name);
            conf.JobDirectory = GetJobDirectoryPath(name);
            if (JobExists(name))
            {
                conf = JobConf.Load(conf.GetFilePath());
            }
            EnqueueJob(conf, stepNumber);
        }

        protected internal void EnqueueJob(JobConf conf, int stepNumber = 0)
        {
            lock (_jobQueueLock)
            {
                if (!_isRunning)
                {
                    StartJobRunnerThread();
                }

                Job job = conf.CreateJob();
                job.StepNumber = stepNumber;
                JobQueue.Enqueue(job);
            }
        }

        Queue<Job> _jobQueue;
        object _jobQueueLock = new object();
        protected internal Queue<Job> JobQueue
        {
            get
            {
                return _jobQueueLock.DoubleCheckLock(ref _jobQueue, () => new Queue<Job>());
            }
        }

        bool _isRunning;
        public void StartJobRunnerThread()
        {
            _runnerThread = new Thread(JobRunner);
            _runnerThread.IsBackground = true;
            _runnerThread.Start();
            _isRunning = true;
        }

        public void StopJobRunnerThread()
        {
            try
            {
                _runnerThread.Abort();
                _runnerThread.Join(2500);
            }
            catch { }

            _isRunning = false;
        }

        private void JobRunner()
        {
            while (true)
            {
                _enqueueSignal.WaitOne();

                while (JobQueue.Count > 0)
                {
                    Job job = null;
                    lock (_jobQueueLock)
                    {
                        if (JobQueue.Count > 0)
                        {
                            job = JobQueue.Dequeue();
                        }
                    }


                    if (job != null)
                    {
                        job.JobFinished += (o, a) =>
                        {
                            Job j = (Job)o;
                            if (Running.Contains(j))
                            {
                                Running.Remove(j);
                            }

                            _runCompleteSignal.Set();
                        };

                        RunJob(job);
                    }
                }
            }
        }

        protected internal void RunJob(Job job, int stepNumber = 0)
        {
            lock (_runningLock)
            {
                if (Running.Count >= MaxConcurrentJobs)
                {
                    _runCompleteSignal.WaitOne();
                }

                Running.Add(job);
            }

            job.Run(stepNumber);
        }

        protected string GetJobDirectoryPath(string name)
        {
            return Path.Combine(JobsDirectory, name);
        }
    }
}
